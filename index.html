<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>Questions</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <link rel='stylesheet' type='text/css' media='screen' href='main.css'>
    <script src='main.js'></script>
</head>
<body>
    <div style='max-width:1000px;word-wrap: break-word;'>
    <p>Domande OC:</p>
    <details>
        <summary>
            23 febbraio
        </summary>
        <div class="content">
            <p>
                <ul>
                    <li>Come funziona l'attribuzione dei ruoli nell'OCDM? In che modo si conserva il ruolo dell'agente nel contesto?</li>
                    <li>A cosa serve ArgumentParser?</li>
                </ul>
            </p>
        </div>
    </details>
    <details>
        <summary>
            2 marzo
        </summary>
        <div class="content">
            <ul>
                <li>
                    Tra gli identifiermanagers, ci sarà anche il MetaID Manager?
                </li>
                <li>
                    Come funziona l'attribuzione dei ruoli nell'OCDM?
                </li>
            </ul>
            
        </div>
    </details>
    <details>
        <summary>
            <p>9 marzo</p>
        </summary>
        <div class="content">
                <li><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAesAAAFzCAYAAAAexiGPAAAG0HRFWHRteGZpbGUAJTNDbXhmaWxlJTIwaG9zdCUzRCUyMmFwcC5kaWFncmFtcy5uZXQlMjIlMjBtb2RpZmllZCUzRCUyMjIwMjItMDMtMDRUMTAlM0E1NCUzQTM4LjU1MlolMjIlMjBhZ2VudCUzRCUyMjUuMCUyMChXaW5kb3dzKSUyMiUyMGV0YWclM0QlMjJXV09xdGpsMXBnZXNHTGREWW1rNiUyMiUyMHZlcnNpb24lM0QlMjIxNi42LjUlMjIlMjB0eXBlJTNEJTIyZGV2aWNlJTIyJTNFJTNDZGlhZ3JhbSUyMGlkJTNEJTIyeTg3bzRmMGU5d1ZRRnBKeEVaUUslMjIlMjBuYW1lJTNEJTIyUGFnZS0xJTIyJTNFM1ZuZmQ1b3dGUDVyZkZ3UEVLdjJzV3E3N2F4YmQ5YnRySHVNY0pXMFFGZ0lWZmJYN3dZU0VLUE9udGJTN2tYSVIzNSUyQjk3czNON0ZISnZIcXZhQnAlMkJKa0hFUFU4SjFqMXlMVG5lYTVEUnZoUVNGRWhwMlJRQVF2QkFsMnBBVzdZSHpBdE5acXpBTEpXUmNsNUpGbmFCbjJlSk9ETEZrYUY0TXQydFRtUDJxT21kQUVXY09QVHlFWiUyRnNrQ0dGVHJ5aGczJTJCQWRnaU5DTzdnN1BxUzB4TlpiMlNMS1FCWDY1QjVLSkhKb0p6V2IzRnF3bEVpanpEUzlYdWNzZlhlbUlDRW5sSUElMkYlMkJhVE1uWVdYNmR4dmYzWHp4SlBxM3UzbWxqUE5BbzF3dldrNVdGWVFBQ0pFUVh1WkFoWCUyRkNFUmhjTk9oWThUd0pRd3poWWF1cGNjWjRpNkNKNEIxSVcycm8wbHh5aFVNYVIlMkZscU5xUWJhdVRZTlpUd1hQdXhaa05FSUZRdVFlJTJCcjFhd3VnZElISElFV0I3UVJFVkxLSDlqeW8xdENpcnRmUWpDJTJCYTZVZXc3bHFzJTJGOGhBS0xYajBKbHFuY3k1UUFVeG5xanhaenlYNnFsMHpxU0JtZnFaZkx1ZWZMUnMxcmJJTW1RU2JsSmFFcmRFUDkzRyUyRmdNSUNhdjklMkZOdDg2UVo5cmZIQ09LOHVMeHVYY1kwZmhHdnVNbkNPeERENTMzVHRIYWpySFhaNkdWMTdGdXMzT0dGcFV4OUZHTCUyRmhSYVE1YkV1emJ5dHpzRVdZJTJGV01KYzJSUkZIRDJ4clhaUDFDYnd5ZHFzMng2TGdRdDFpcWtuQ1V5VyUyQnY1cXdJYSUyQjlleFNBdUF1QnZiNU9QcTQwczFnMFlDOVZLZXNDR1FMaVFBS3ladjE5NSUyRnFhNU9UblZwdXRJOWw0WENGQkpjNlcxVFVSViUyRm1UNVVvV2xXbGt5N0R1VG1kaG9MM2FIbDZRbXZHbTB6OVJXZFllYmNNZyUyQk4yQ0xCZHg4Wnd1eUFqRlVjWkppYW51c1BNUXVDU2dtUXNUOTBWdmFueU5ZJTJCZ1oyZmpudW4wMzJCVk9mTnVuR3Z6bGJYRGJOSHNqdkRybk15N0xjRGIxVjZuTE0zM21tcThQazhBMmxaNXpsOHNQOVdmUEM1ZmVtcElkbUtvZldXYW1MbzVuWmElMkJhNXVkUVJUMnNjYTdKTCUyQk42NjN3MnExNncyOElYbGJ6dGUzRFBhOVNBRVJQaTlQT2lrZWdNaWxaVDRSOG5pV1p5JTJCU1NHNW8ydHR5eGhsdHlTUkh4OG9rN2YzRkQ4RyUyRlI2ak1LSlc4TXBaSlNId2NhN0o1cUZSQWl1TEZ6MkRPa3NwSGJJcTdQVXFTTFFuN0N4OGxIWXZvTGphS1p3ejY3cUdYSk41WnB4bVVmVTN5UFlSQ1g1T1VDNDNMRUNIRDh2SkV5VGVnU3NMMWpRbFRQNTFMMm5OZTIlMkZXSVp4OURUZkF3RzZVZFB6YkR4ZWN5WERnZyUyRlpOWFIlMkZFckNCdjJaY2diRHh2ZTJZRmhnM1I3Q1hWbUVYJTJCZVpTcHRxMjVRSmNRcEY3U2NrZXBvckxTdXhZOGJwS29Sd3VaMnVhNzREU1AlMkJROXh0Q3o3TEJ2bmFvZ214QTNYUEcwUTQ3SGpPeXdUUzV4RXlxNzRNZnVmcUR3OGtnbHhlT282YWV3TU5GdW81emxrVWFHTmx2bUNwNmdGWjlrTjglMkZzNUJzUEtPZktlVnJpZG05Smt3ZlJvRTExZE55Y0NkWnpzYldhVjNQR05pc2ZtM3FVcmNtJTJGJTJGc3lNVmYlM0MlMkZkaWFncmFtJTNFJTNDJTJGbXhmaWxlJTNF+U1nUwAAIABJREFUeF7tnQ2wVsWZ5xuNCCqoqBcxmLKGLYtkEhgwxIR1srtDzcIGSGKyxEA2ioGNVUHKm9lZIy4EESLEqRgsdFMTQZNoYEcrHxtlF2rK7M6Mq5WgUPfGJGxqmbLiFxdjVPAjYJTt51yea9++3ef0+e7u83+rjnLf95zup//9dP/O06f79CiBDxSAAlAACkABKOC1AqO8tg7GQQEoAAWgABSAAgKwhhNAASgABaAAFPBcAcDa8wqCeVAACkABKAAFAGv4ABSAAlAACkABzxXoAqypjJfI44OnnXbapaecckrPSSeddI48zj169OgZx44do+P00aNHvzZmzJjXR40a9ZL89xH53cArr7zyjLxunzyekMfj8jjueX3CPCgABaAAFIhQgRhhfZKspyvOOOOMfyPB/C8lcKdeeOGFL1966aXHTz755HM++clPirPPPnvYcdZZZ4mXX35ZvPTSS8OOH//4x0JC/dXHHnvsraeeemrcmWeeuV+e81OZ/qPy+Dt5vB2hT6BIUAAKQAEo4JkCMcH6L8eOHfv5P/7xj5+ZPXv20Y997GOnfPjDHx57ySWXiNNPP7207K+99pp44oknxOOPPy5++MMfvvjzn//8jDfffPNemfD98vj70hkgASgABaAAFIACFgVCh/Xp48ePv1lCc/F73vOeMVdfffWYJUuWjJWRdO0V/vTTT4v7779f3HXXXS8999xzfzxy5MhdMtNb5PFa7ZkjAygABaAAFOiUAiHD+jo5zH3T4sWLT+7t7R03Y8aM1ipu37594o477ji2ffv2o3/4wx/WSENub80YZAwFoAAUgALRKRAirBePGzfuFvkM+uxbbrnlzFmzZnlTKXv27BE33njjK3v37n3197///X+Whu3wxjgYAgWgABSAAsEqEBSs5TPp71100UXzb7311gkLFizwVvSHHnpIrFq16vCBAwf++xtvvHGlt4bCMCgABaAAFAhCgVBg/Sfy2fQDCxcuvPi+++47IwhlpZFLly499qMf/ejJw4cPL5J//nModsNOKAAFoAAU8EuBEGA979RTT/1vX/3qV0fLIeaxfsmXbY0cBRDr1q179fXXXydg78q+AmdAASgABaAAFBiugO+w/nP5kpL/LZdKnUTro0P90HrtT33qU28fP378X8sy/FOo5YDdUAAKQAEo0I4CPsN6kpxI1idnWZ9+5ZVXntaOPNXl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" style="cursor:pointer;max-width:100%;" onclick="(function(img){if(img.wnd!=null&&!img.wnd.closed){img.wnd.focus();}else{var r=function(evt){if(evt.data=='ready'&&evt.source==img.wnd){img.wnd.postMessage(decodeURIComponent(img.getAttribute('src')),'*');window.removeEventListener('message',r);}};window.addEventListener('message',r);img.wnd=window.open('https://viewer.diagrams.net/?client=1&page=0&edit=_blank');}})(this);"/>
      </li>
        <li>Sto pensando al procedimento che dovrà esserci all'interno di Croci, e mi sono fermato qui. Non mi è chiaro se negli script c'è già qualcosa che faccia query basate sugli altri metadati.</li>
        </div>
    </details>
    <details>
        <summary>
            <p>22 marzo</p>
        </summary>
        <div class="content">
            <ul>
                <li>In questi giorni ho fatto un po' di test su cnc.py per croci, per vedere esattamente come va. Ho fatto un fork dell'index per modificare i diversi script.</li>
                <li>Mi sono bloccato perché sto avendo problemi con l'header di un mock csv che sto usando per fare i miei test. Non capisco se c'è un errore nel modo in cui ho impostato il csv.</li>
                <li>Legge le chiavi del DictReader come <pre>"doi:10.1234/test","i"</pre></li>
                <li><a href='to_test.csv'> Qui c'è il csv che sto testando</a></li>
                <li>Il comando che sto usando è </li>
                <code>python cnc.py -c croci -i "mockup_data/to_test.csv" -d "given_data" -l "index/test_data/lookup_full.csv" -b "https://w3id.org/oc/index/croci/" -ib "http://dx.doi.org/" -doi "invalid_doi/data.csv" -s "https://example.org/" -v -a "https://w3id.org/oc/index/prov/pa/1" -sv "https://example.org/"</code>
                </ul>
        </div>
    </details>
    <details>
        <summary>
            <p>29 marzo</p>
        </summary>
        <div class="content">
            <ul>
                <li>Sto iniziando a creare le funzioni per validare un MetaID, per ora inviare richieste ma lavorando solo per verificare che riconosca se a Croci arriva un DOI o un MetaID. Per ora farò solo in locale lavorando sulla stringa, in futuro vorrei aggiungere anche via API un controllo se questo esiste. <b>Ci vuole un validate, che sarà una query ask su meta. se è cancellato, trova quello nuovo. Funzione esiste già: idmanager restituisce in output il metaid della risorsa, o il metaid stesso se è riconosciuto come valido. </b> </li>
                <li>Volevo chiedere, per gestire questa molteplicità, immagino dovrò cambiare le funzioni su più livelli. Croci dovrà funzionare a contatto con Meta per pescare gli articoli già presenti, quindi:
                    <ol>
                        <li>Se MetaID-to-MetaID, valida i MetaID; se non ci sono, invalida la citazione.</li>
                        <li>Se DOI-to-DOI, fa quello che fa ora + verifica su Meta per arricchire di informazioni</li>
                        <li>Se MetaID-to-DOI o viceversa, controlla su Meta e trasforma in MetaID-to-MetaID</li>
                    </ol>
                    Quindi, stavo riflettendo che crowdsourcecitationsource, che ora come ora va a lavorare direttamente sui DOI, dovrà probabilmente essere diviso tra una parte doicrowdsourcecitationsource e un metaidcrosourcecitationsource. Non so se ha senso questa cosa. <b>Più identificativi!!!! A fine processo: risorse nuove. Problema: bisogna cacciare a forza le informazioni sulla tabella arricchita. Conflitto tra due DOI e MetaID. </b>
                </li>
                <li>In generale, sto avendo problemi ad importare le funzioni, spesso se lancio qualcosa anche da commandline mi dà ModuleNotFoundError perché non trova l'index. Non sto ben capendo come risolvere questa cosa.<b>vedi .env vscode. Bisogna lanciare con py -m e le dir separate da punti es. py -m index.my_test.01_test_metaid_identifier </b></li>
            </ul>
        </div>
    </details>
    <details>
        <summary>
            <p>4 aprile</p>
        </summary>
        <div class="content">
        <ul>
            <li>
                Ora che riesco a far girare i test, ho iniziato a creare il MetaIDManager per validare in locale i MetaID (per ora riferiti solo a bibliographic resources) validi. Per ora non verifica l'esistenza di MetaID; in seguito dovrà lavorare a fianco di una instance di Creator da Meta e fare il giochino con l'id worker, verificando che l'id esiste in Meta se è un metaid o recuperandolo/creandolo se è dato un doi
            </li>
            <li>
                Ho preparato una funzione ausiliaria per gestire più id. Non so se ha senso tenerla distinta dalle altre funzioni per normalizzare gli id.<b>Partiamo dal presupposto che il prefisso è presente. L'aggiunta potrebbe cvvenire in reprocess. DA IDWORKER: se input =/= output il metaid non esiste.</b>
                <pre><code>
                    from re import match

                    def normalise_multiple_ids(id_list, doi,metaid):
                        normalised_ids=None
                        for id in id_list:
                            if match('10\..+\/.+$',id):
                                # It's a DOI! So, normalise it as a doi. Put it in the normalised citing dict if it's normalisable.
                                # If there are multiple dois, use the first one
                                if not normalised_ids:
                                    id = doi.normalise(id)
                                    normalised_ids= {'doi':id}
                                elif 'doi' not in normalised_citing:
                                    normalised_citing['doi'] = id
                    
                            elif match('^060|^br\/060|meta:br\/060'): <b>Importante: c'è 06 all'inizio, 0 alla fine NO 0 in mezzo</b>
                                if not normalised_citing:
                                    id = metaid.normalise(id)
                                    normalised_citing = {'metaid':id}
                                elif 'metaid' not in normalised_citing:
                                    normalised_citing['metaid'] = id
                        return normalised_ids
                    </code></pre>
            </li>
            <li>
                Per la parte di Ramose, ho iniziato a guardare gli elementi necessari per caricare su pypi, oltre che ovviamente agli script.<b>Account su pypi per pubblicarci. readthedoc.io</b>
            </li>
        </ul></div>
    </details>
    <details>
        <summary>
            <p>11 aprile</p>
        </summary>
        <div class="content">
            <ul>
                <li>Ho cambiato croci per fare in modo che, a seconda del prefisso, usi l'idmanager corretto. Ho anche corretto per tenere conto del metaid come <code>'^06[1-9]*0$'</code>. Ho anche iniziato a fare i test case (per ora solo per i doi). Intanto, volevo chiedere se c'è un dump di metaid che posso usare per fare questi test.<
                    b>Senti Arcangelo</b> </li>
                <li>Ho iniziato a guardare poetry e a creare le varie dependencies<b> CROCI parte da file corretto, deve fare un preprocess che ti dà la tabella metaid to metaid. INPUT per meta: tabella con pub date e id. ouput: campo id + metaid. </b></li>
                <li><a onclick="showthis('toml1');">Ho creato il file .toml per iniziare a testarlo</a><b></b></li>
                <li id="toml1"><pre><code>
                    [tool.poetry]
                    name = "ramose"
                    version = "0.0.2"
                    description = "Restful API Manager Over SPARQL Endpoints (RAMOSE) is an application that allows agile development and publication of documented RESTful APIs for querying SPARQL endpoints, according to a particular specification document."
                    authors = ["essepuntato <essepuntato@gmail.com>"]
                    license = "ISC"
                    repository = "https://github.com/opencitations/ramose/"

                    [tool.poetry.dependencies]
                    python = "^3.8"
                    certifi = "2019.11.28"
                    chardet = "3.0.4"
                    Click = "7.0"
                    Flask = "1.1.1"
                    idna = "2.8"
                    isodate = "0.6.0"
                    itsdangerous = "1.1.0"
                    Jinja2 = "2.11.3"
                    Markdown = "3.1.1"
                    MarkupSafe = "1.1.1"
                    python-dateutil = "2.8.1"
                    requests = "2.22.0"
                    six = "1.13.0"
                    urllib3 = "1.26.5"
                    Werkzeug = "0.16.0"

                    [tool.poetry.dev-dependencies]

                    [build-system]
                    requires = ["poetry-core>=1.0.0"]
                    build-backend = "poetry.core.masonry.api"

                </code></pre></li>
            </ul>
        </div>
    </details>
    <details>
        <summary>
            <p>25 aprile</p>
        </summary>
        <div class="content">
            <ul>
                <li>
                    Per CROCI, su suggerimento di Arcangelo, ne ho ripensato il funzionamento. Al posto di partire da una tabella con id multipli, partirà con una tabella solo MetaID-to-MetaID. Per fare questo, dovrebbe interfacciarsi con Meta; a questo fine, deve avvenire un preprocess che trasformi la tabella in input compatibile con Meta, in modo da successivamente arricchirla. <b>DA META CI PASSIAMO SOLO CON DOI VALIDI. METADATI: RECUPERA DA SERVIZI ESTERNI. ID ENRICHER. vedi opencitations/oc_graphenricher. copia repo di meta in croci</b>
                    A questo punto, però, si pone il problema di legare il processo di Croci a Meta, quindi all'azione di qualcuno che faccia partire Meta. Quindi:
                    <ol>
                        <li>
                            Potremmo legare l'upload delle citazioni su Croci al primo processo Meta che parte? Avrebbe senso / come si potrebbe fare?
                        </li>
                        <li>
                            Il processo CROCI in origine si occupava della normalizzazione dei DOI. In questo caso, pensavo si potrebbe collegare semplicemente a Meta, che già di questo si occupa. 
                        </li>
                        <li>
                            Per ora non ho inserito uno script che faccia mapping, ma ho fatto un procedimento 'stupido' che assegna i file in ordine row-first in modo da ricollegarsi con questo all'ordine di output e input di meta. In alternativa, potrebbe avere senso usare un pointer che indichi a che riga si trova l'informazione nella tabella di meta. In ogni caso, questi metodi seguono l'assunto che l'output di meta segua l'ordine dell'input. 
                        </li>
                    </ol>
                </li>
                <img src='CROCI Preprocess.png'>
                <li>Un'altra cosa che ho notato che è da implementare sono le self citations. Anche qui può essere d'aiuto Meta.<b>LO FA AUTOMATICAMENTE INDEX; non te ne proccupare. </b></li>
                <li>Rispetto a Ramose, ho provato a collegare ReadTheDocs alla libreria, ma mi dà degli errori tra i requirements. Sto provando a testarlo in locale cambiando alcune impostazioni, ma devo anche cambiare alcune cose perché i test sono pensate non per Windows e quindi mi sta facendo dei capricci.  Per questo ho creato un test_windows.sh per lanciarlo con più facilità da Windows.<b>Dopo croci cerca se cit c'è già</b></li>
            </ul>
        </div>
    </details>
    <details>
        <summary>
            <p>2 maggio</p>
        </summary>
        <div class="content">
            <ul>
                <li>Ho iniziato a guardare oc_graphenrcher. Ho provato ad usare le funzioni già presenti per usare le API, ma richiedono alcuni parametri che dalla tabella di CROCI non sarebbero presenti. In particolare, in origine usa: DOI, autori (opzionale) e titolo.
                    Quindi, ho pensato a questo ordine di query:
                    <ol>
                        <li>
                            Crossref/Wikidata: Recupera dati su pubblicazione da DOI/Wikidata. Questa parte richiede una propria funzione.
                        </li>
                        <li>
                            Se così facendo è stato recuperato un autore: popolare con ORCID e VIAF etc.
                        </li>
                    </ol>
                    In questo modo dovrei poter estrarre gli elementi che necessita Meta, cioè <code>id,title,author,pub_date,venue,volume,issue,page,type,publisher,editor
                    </code>. <br>
                    Su questo codice sto lavorando indirettamente anche per l'esame di Open Science.

                </li>
                <li>
                    Per quanto riguarda Ramose, ho provato a cambiare i requirements mettendo l'ultima versione di requests e sembra non dare più problemi per quanto riguarda la versione. A questo punto volevo chiedere: prima di caricare la library, può essere sensato provare se l'ultima versione delle librerie utilizzate funziona? C'è qualche best practice a riguardo o vado a naso? <b>Pattern matching; confrontati con Giuseppe/Arcangelo. Da PY3.5 a Py3.10</b>
                </li>
            </ul>
        </div>
    </details>
    <details>
        <summary>
            <p>9 Maggio</p>
        </summary>
        <div class="content">
            <ul>
                <li>Sto costruendo lo script per popolare il file. Innanzitutto, mi sono accorto che ci sono più titoli su crossref (short title, title, original title). Quali tengo? O posso tenerli tutti per darli a Meta? <b>vedi crossref processing di arcangelo.</b>

                </li>
            </ul>
        </div>
    </details>
    <details>
        <summary>
            <p>24 Maggio</p>
        </summary>
        <div class="content">
            <ul>
                <li>Non ho avuto granché tempo per lavorare su Croci. Ho applicato il plugin di Meta per gestire l'output di Crossref.
                    <b>problema interno di meta: niente ORCID. Vedi bene anche per i VIAF</b>
                </li>
            </ul>
        </div>
    </details>
    <details>
        <summary>
            <p>31 maggio/6 giugno</p>
        </summary>
        <div class="content">
            <ul>
                <li>Questa settimana ho lavorato sullo script per popolare le righe da poi dare in feed a Meta. per fare questo ho creato uno script che:
                </li>
                <ol>
                    <li>
                        Dato un identificativo in input, lo valida sui servizi dati.
                    </li>
                    <li>
                        Se valido, cerca tra tutti i servizi (per ora  WikiData e Crossref) se esiste una corrispondenza. Se sì, ritorna gli identificativi.
                        Lo script è qui sotto, con il processo decisionale.
                    </li>
                </ol>
                <li>
                    Domande:
                    <ol>
                        <li>
                            Che User Agent uso per wikidata? per ora sto usando abusivamente quello di oc_graphenrcher
                        </li>
                        <li>
                            Dovrei selezionare le entity su Wikidata che sono articoli scientifici e libri, ma Wikidata è un po' balorda. Devo tenere conto del fatto che l'utente può specificare una cosa a caso come identificativo? c'è anche il problema che scholarly aticles sono segnati come cose a caso (e.g. https://www.wikidata.org/wiki/Q2640 sarebbe un articolo per wikidata). cosa faccio? tengo wikidata solo come lookup? Values che mantengo per ora: wd:Q13442814 (scholarly article) wd:Q571 (book) wd:Q88392887 (part of work) wd:Q1143604 (proceedings) wd:Q7318358 (review article)
                            Una soluzione che mi è venuta in mente è di verificare la presenza di altri id per confermarla
                        </li>
                        <li>
                            Dato che CROCI dovrà essere, in conclusione, any-to-any, potrebbe avere senso utilizzare altri identificativi che WikiData dà come connessione? (Fatcat, ResearchGate, Publons, arxiv etc.). Tra questi c'è spesso anche l'OC corpus id; per ora non l'ho inserito.
                        </li>
                    </ol>
                </li>
                <li>
                    Per quanto riguarda Ramose, sto creando i vari test da lanciare con poetry per vedere la coverage. Per ora in realtà la coverage sembra essere piuttosto bassa. Per ora sto usando la libreria coverage per testare la coverage.
                </li>
                <li>
                    <img src="Meta_Preprocess.drawio.png" alt="meta preprocess" width="100%">
                </li>
                <li>
                    <script src="https://gist.github.com/dbrembilla/1d4abb4c542ebb9e310114d881d31103.js"></script>
                </li>
            </ul>
        </div>
    </details>
    <details>
        <summary>
            <p></p>
        </summary>
        <div class="content">
            <ul>
                <li>
                </li>
            </ul>
        </div>
    </details>
</body>
</html>
